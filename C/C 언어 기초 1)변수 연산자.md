# C 언어 기초
금일 기준으로 c 언어 복습을 시작하겠다. 교재는 [씹어먹는 c언어]라는 교재로 psi라는 저자분이 무료로 배포한 pdf를 기준으로 일주일 동안 필요한 부분만 빠르게 복습할 예정이다.

c언어 기초 지식들은 널리 알려진 개념들이 워낙 많고, 또한 그 개념들을 전부 훑고 넘어가기엔 애로사항이 있으므로 쉽게 틀릴만한 개념들 위주로 포스팅을 작성하려고 한다.

### 1. 변수
---
변수 이름은 알파벳 숫자의 조함으로 작명하고 _을 통해 띄어쓰기를 구별한다. 숫자가 먼저 위치하면 안되고, 알파벳의 대문자, 소문자를 구별해서 적어야 한다.

변수를 지정할 땐 자료형을 지정해줘야 하는데, 자료형에 따라 해당 변수의 크기가 바뀌고 이후 연산의 과정에서 도출값도 달라지게 된다.
![](https://velog.velcdn.com/images/dehite0704/post/1a677e84-255c-4ca6-8ba6-ee4770071518/image.png)
###### 출처:<https://program-rest-area.tistory.com/6>(접속일: 2025-01-19)
위의 도표를 기준으로 본인이 원하는 자료형을 지정해서 변수를 선언 가능하다.

변수를 printf 함수에서 표현시 다양한 방식으로 터미널에 표현 가능하다.
```
#include <stdio.h>
int main() {
  float a = 3.141592f;
  double b = 3.141592;
  int c = 123;
  printf("a : %.2f \n", a);
  printf("c : %5d \n", c);
  printf("b : %6.3f \n", b);
  return 0;
}
```
위의 예시처럼 코드를 입력하면 도출값은 다음과 같다.
```
a : 3.14 
c :   123 
b :  3.142
```
%6.3에서 6은 전체 6자리로 표현하라는 의미이고, .3은 소수점 셋째자리로 반올림하라는 의미이다.

### 2. 연산
앞서 선언한 변수들로 자유롭게 연산을 수행가능하다. 이때 쉽게 틀릴 수 있는 부분들이 몇가지 존재하는데, 다음의 예시를 분석해보자.
```
int c = 10;
int d = 3;
double e = 3.0;
printf("10/3 = %d\n",c/d); //int int 계산은 int 가 나온다.
printf("10/3 = %f\n",c/e); //int double 계산은 double 값이 나온다.
```
위의 예시처럼 입력할 시, 3, 3.33333 이렇게 값이 도출되는 것을 볼 수 있다. int int 자료형 연산은 결과로 int가 나오고, int double/ double double 계산은 결과로 double 자료형이 나온다.

비트 연산자라는 개념이 존재한다. 여기서 많이 헷갈리는 개념이 역을 취하는 개념인데, 다음의 코드를 분석해보자.
```
#include <stdio.h>
int main() {
  int a = 0xAF;  // 10101111
  int b = 0xB5;  // 10110101

  printf("%x \n", a & b);   // a & b = 10100101
  printf("%x \n", a | b);   // a | b =10111111
  printf("%x \n", a ^ b);   // a ^ b = 00011010
  printf("%x \n", ~a);      // ~a = 1....1 01010000
  printf("%x \n", a << 2);  // a << 2 = 1010111100
  printf("%x \n", b >> 3);  // b >> 3 = 00010110

  return 0;
}
```
a라는 16진수 숫자를 역을 취했을 때, 흔히들 01010000라고 생각하지만, a는 32비트 짜리 메모리를 가지는 int변수라는 사실을 망각하면 안된다. 따라서 모든 32bit를 역을 취하면 결과는 다음과 같다.
```
a5 
bf 
1a 
ffffff50 
2bc 
16 
```
ffffff50으로 표기된 것을 볼 수 있다.

2의 보수 연산은 음수를 표기할 때 유용한 방법이다.
0101 - 5의 음수 표기인 -5를 구해보자. 0101 + x = 0000 이라는 방정식을 가정한다.(이때 자료형의 메모리는 4bit라고 하자.) 우리는 x 자리에 1011이 들어와야지 10000에서 1이 잘려서 0000이 될것이라고 예상할 수 있다. 즉 -5는 1011이다.
이 4비트짜리 자료형을 분석하면, 최대 0111(7) 최소(1001)까지 표현가능하다는 사실을 알 수 있다. 이를 통해 앞자리가 0이면 양수, 1이면 음수라고 정의할 수 있다.(0000이 남는데, 0000은 2의 보수가 10000 즉 0000이므로 -8이라고 놓는다.)

이로써 int를 분석할 수 있는 기본 틀을 가지게 되었다.
```
int h = 2147483647; // int 가 표현할 수 있는 수는 -2147483648 부터 2147483647까지이다.
printf("h : %d\n", h);
printf("h : %d\n", h+1);
```
이를 실행하면 어떤 결과가 나올까?
2의 보수법에 의해 최대 숫자에 1을 더하면 10000... 0 이므로 앞자리가 잘려서 0000..00 만 남는다는 사실을 알 수 있다. 따라서 결과는 다음과 같다.
```
2147483647
-1
```
이처럼 자료형이 지정된 메모리를 넘어서는 입력값에 대해서 엉뚱한 출력값이 출력되는 것을 오버플로우라고 정의한다.

undigned int는 음수값이 없는 32비트 자료형이다. 0에서 4294967295까지 표현 가능하다. -1을 대입하면 어떤일이 벌어질까? -1은 1의 보수이므로 0xffffffff로 표현이 되므로 이를 그대로 나타낸 4294967295이 출력된다. 그렇다면 4294967295 + 1 을 입력하면, 0xffffffff + 1이므로 0이 출력되는 오버플로우가 일어나게 된다.
```
#include <stdio.h>

int main() {
  unsigned int b = 4294967295;
  printf("b : %u \n", b);

  b++;
  printf("b : %u \n", b);

  return 0;
}
```
```
b : 4294967295 
b : 0 
```
2의 보수법은 다양한 문제에 활용되므로 까먹지 않도록 유의하자.