저번 포스트에 이어서 pointer 포스트 2번째이다.

이번 포스트는 저번과 이어서 배열과 포인터에 관한 이야기를 심도 있게 진행해보도록 하겠다.

### 1) 배열과 포인터
앞서서 설명하였듯이 arr은 그 자체로 사용되었을 때, arr[0] 주소값을 지정하게 되어있다. 예외는 두가지 경우인데, sizeof를 사용했을 때와 &연산자를 사용했을 때이다.

그렇다면 다음과 같은 코드를 분석해보자.
```
#include <stdio.h>
int main() {
  int arr[3] = {1, 2, 3};
  int *parr;

  parr = arr;
  /* parr = &arr[0]; 도 동일하다! */

  printf("arr[1] : %d \n", arr[1]);
  printf("parr[1] : %d \n", parr[1]);
  return 0;
}
```
여기서 parr이라는 포인터는 arr[0]의 주소값을 가리키고 있다. 따라서 parr[1]이 *[parr + 1]로 변환되면서 둘다 2가 출력되는 것이다.

따라서, parr 을 통해서 arr 을 이용했을 때와 동일하게 배열의 원소에 마음껏 접근할 수 있게 되는 것이다.

그렇다면 다음과 같은 코드는 어떨까?
```
#include <stdio.h>
int main() {
  int arr[10] = {100, 98, 97, 95, 89, 76, 92, 96, 100, 99};

  arr++;  // 오류
  return 0;
}
```
arr은 그저 arr[0]의 주소값을 나타내는 것일 뿐 포인터로서의 설정이 하나도 되어있지 않다. 앞선 포스트에서 강조했듯이 배열은 배열이고 포인터는 포인터일뿐. 따라서 arr++은 그냥 arr[0]주소값에 ++을 한것이다. 아무 의미가 없는 것이다.

### 2)포인터의 포인터
int **p;에 관하여 고민해보자.
이는 p를 가리키는 포인터의 포인터인것이다.

### 3)&연산자
arr의 예외사항 중 하나가 &arr로 사용될때라고 하였다. 그렇다면 &연산자는 무슨 역할을 하는것일까?
```
#include <stdio.h>

int main() {
  int arr[3] = {1, 2, 3};
  int (*parr)[3] = &arr;

  printf("arr[1] : %d \n", arr[1]);
  printf("parr[1] : %d \n", (*parr)[1]);
}
```
위의 코드에서 먼저 int (*parr)[3] = &arr; 부분을 분석하자.
arr 이 크기가 3 인 배열 이기 때문에, &arr 을 보관할 포인터는 크기가 3 인 배열을 가리키는 포인터가 되는것이다. 여기서 중요한 점은 크기가 3이라는 점이다. 즉 arr이 배열로서 기능하고 있다는 사실을 알 수 있다.

이러한 주소값을 받으려면 포인터도 특별하게 초기화되어야 한다. 이때 int (*parr)[3]형식으로 받게된다. int는 int형 배열이라는 뜻이다.

만약 괄호로 감싸지 않고 int *parr[3]라고 써버리면 이는 단순히 int* 포인터들을 원소로 갖는 크기 3의 배열이 되어버린다. 따라서 정확한 형식을 지키도록 하자.

한 가지 재미있는 점은 parr 과 arr 은 같은 값을 가진다는 점입니다. 이는 어찌보면 당연한 사실인데 여기서 중요한 점은 arr 자체가 어떤 메모리 공간에 존재하는 것이 아니라는 점이다.

여기서 arr값이 왜 이렇게 자동 지정이 되는지에 대한 비밀이 풀린다. 원래 C언어 전에 있었던 언어인 B언어에서 arr은 실재로 arr[0]을 가리키는 포인터였다. 하지만 C언어를 만들면서 불필요한 저장공간을 없애기 위해 지금과 같은 형태로 정착한 것이다.

### 4)이차원 배열
사실 이차원 배열은 단순히 1차원 배열이 행의 개수만큼 존재하는 것과 다를 바가 없다. 모든 원소들은 메모리 상에서 연속적으로 저장된다. 따라서 주소값의 차이도 1차원 배열과 동일하다.

다음 코드를 보자.
```
#include <stdio.h>
int main() {
  int arr[2][3];

  printf("arr[0] : %p \n", arr[0]);
  printf("&arr[0][0] : %p \n", &arr[0][0]);

  return 0;
}
```
여기서 arr[0]가 arr[0][0]의 주소값과 똑같다는 사실을 볼 수 있다. 이 경우 arr과 비슷하게, arr[0]는 arr[0][0]을 가리키는 포인터로 타입변환된다는 사실을 배울 수 있다. 단 sizeof 와 &연산자를 썼을때는 예외이다.

따라서 sizeof를 쓰면 다음과 같은 연산도 가능하다.
```
int main() {
  int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
  printf("전체 크기 : %d \n", sizeof(arr));
  printf("총 열의 개수 : %d \n", sizeof(arr[0]) / sizeof(arr[0][0]));
  printf("총 행의 개수 : %d \n", sizeof(arr) / sizeof(arr[0]));
}
```
arr 와 arr[0]가 모두 배열로 기능하는 것을 볼 수 있다.

이제 2차원 배열을 받는 주소값을 지정해보자.
```
#include <stdio.h>
int main() {
  int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
  int **parr;

  parr = arr;

  printf("arr[1][1] : %d \n", arr[1][1]);
  printf("parr[1][1] : %d \n", parr[1][1]);

  return 0;
}
```
다음과 같이, arr이 주소값이므로 포인터의 포인터를 이용해서 arr을 받을 수 있을까?

정답은 아니오이다. 실행해보면 parr[1][1]에서 오류가 뜨는 것을 볼 수 있는데, 이는 parr이 잘못된 주소를 찾아갔기 때문에 코드가 실행이 안된것이다.

그렇다면 왜 이런상황이 발생했을까?

우선 arr[3][2]라는 행렬이 정해졌을 때 arr[x][y]는 어떤 주소값을 가지는 지 생각해보자.

arr+4bx+4y라는 것을 볼 수 있다. 여기서 중요한 점은 b가 필요하다는 점이다. 따라서 2 차원 배열을 가리키는 포인터를 통해서 원소들을 정확히 접근하기 위해서는;

1) 가리키는 원소의 크기 (여기서 4)

2) b 의 값

위 두 정보가 포인터의 타입에 명시되어 있어야지 컴파일러가 원소를 올바르게 접근할 수 있습니다.

```
int main() {
  int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
  int(*parr)[3];  // 괄호를 꼭 붙이세요

  parr = arr;  // parr 이 arr 을 가리키게 한다.

  printf("parr[1][2] : %d , arr[1][2] : %d \n", parr[1][2], arr[1][2]);

  return 0;
}
```
이것이 올바른 예시이다. 따라서 우리는 앞서 배웠던 배열의 포인터가 왜 저런 모양인지 이제야 알게된 것이다.

의문인 점은 앞서 *parr = &arr을 통해 1차원 배열의 주소값을 받았던 parr은 원소에 접근할 때

(*parr)[1]이런식으로 접근하였다. 하지만 위의 코드는 parr = arr로 직접적으로 접근하는 것으로 볼 수 있다.

1차원과 2차원이라서 다른것인가?

### 5)포인터의 형
여기서 포인터 형에 관해서 자세하게 짚고 넘어갈 필요성이 있다. 다음과 같은 코드를 보자.
```
#include <stdio.h>

int main() {
  int arr[3] = {1, 2, 3};
  int (*parr)[3] = &arr;    // arr은 int*형 포인터, &arr은 int*[3]형 포인터

  printf("arr[1] : %d \n", arr[1]);
  printf("parr[1] : %d \n", (*parr)[1]);
}
```
앞서 작성했던 1차원 배열의 코드이다. 여기서 (*parr)[3]은 

int*[3]형 포인터를 정의한 것이다. 따라서 포인터의 형을 맞춰야 한다.

arr 은 그 자체로 포인터 역할을 하지만 그 형은 int*이다. 

그래서 우리는 포인터 형을 맞추려고 &arr 즉 int*[3]형으로 맞춰준것이다.

그렇다면 2차원 배열의 코드를 보자.
```
#include <stdio.h>
int main() {
  int arr[2][3] = {{1, 2, 3}, {4, 5, 6}};
  int(*parr)[3] = &arr;  // 이때 &arr은 int*[2][3]형 포인터 arr은 int*[3]형 포인터

  printf("parr[1][2] : %d , arr[1][2] : %d \n", parr[1][2], arr[1][2]);

  return 0;
}

```
여기서 arr은 1차원 배열과 다르게 int*[3]형 포인터이다. 즉 그대로 쓰면 자연스럽게 형 맞춤이 일어나는 것이다.

오히려 &arr이라고 해버리면 int*[2][3]형 포인터가 되버리므로 형이 맞지 않게 된다.

여기서 질문이 생긴다. 형이 맞지 않으면 코드가 실행되지 않아야 하는거 아닌가?

형이 맞지 않아도 arr과 &arr은 가지고 있는 주소값이 동일하므로 코드 자체는 실행된다. 하지만 형에 관한 오류메시지가 출력되는 것을 확인 가능하다.

#### ps)본론으로 돌아가 parr[1][1]은 무슨 역할을 하였는가?

먼저 parr[1][1] 은 ```*(*(parr + 1) + 1)``` 과 동일한 문장이다. parr + 1 을 하면 뭐가 될까? 

지금 parr 은 int* 를 가리키는 포인터 이고, 

int* 의 크기는 8 바이트 이기 때문에 parr + 1 을 하면 실제 주소값이 8 증가하게 된다.

따라서 parr + 1 은 arr 배열의 세 번째 원소의 주소값을 가지게 된다. (왜냐면 int 는 4 바이트 니까). 따라서 *(parr + 1) 은 3 이 될 것이다.

그 다음에 *(parr + 1) + 1 을 하면 몇이 증가할까? 

현재 (parr + 1) 의 타입은 int * 이다. 

따라서 int 의 크기 만큼인 4 가 늘어나게 된다. 

결국 *(parr + 1) + 1 은 7 이다.

그래서 결국 ```*(*(parr + 1) + 1)``` 은 마치 주소값 7 에 있는 값을 읽어라! 하는 말과 동일하다. 

그리고 해당 위치는 프로그램이 읽을 수 없기에 오류가 발생하게 되는 것이다.

### 6)포인터 배열
배열의 포인터와 다른말이다. 앞서 설명했던 대로 (*parr)[3]에서

int* parr[3]이라고 정의하면 포인터를 저장하는 배열이 된다.
```
#include <stdio.h>
int main() {
  int *arr[3];
  int a = 1, b = 2, c = 3;
  arr[0] = &a;
  arr[1] = &b;
  arr[2] = &c;

  printf("a : %d, *arr[0] : %d \n", a, *arr[0]);
  printf("b : %d, *arr[1] : %d \n", b, *arr[1]);
  printf("b : %d, *arr[2] : %d \n", c, *arr[2]);

  printf("&a : %p, arr[0] : %p \n", &a, arr[0]);
  return 0;
}
```
이렇게 포인터를 저장하는 배열을 만들 수 있다.

이렇게 포인터에 대해서 심화적으로 다루었다. 과거에 이해가 가지 않았던 부분들을 다시 확실하게 다지고 넘어갈 수 있는 기회가 된것 같아서 진심으로 기분이 좋았다.