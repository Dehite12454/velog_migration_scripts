이번 포스트에서는 모든 프로그램의 꽃이라고 불리우는 pointer 에 대해 다루어보도록 하겠다. 과거 포인터를 배울 때 그 어려움에 좌절을 겪었던 나지만, 한번 배웠던 경험으로 이 강의의 모든 것을 이해하겠다는 마음가짐으로 이 글을 쓰고 있다.

자 들어가보자.

### 1)pointer의 개요
---
int a = 123;
라는 코드가 있다고 해보자. 이는 메모리의 어떤 부분에 4바이트짜리 공간을 만들고 그 공간에 123라는 숫자를 저장하라는 의미이다. 여기서 우리가 원하는 부분은 이 ***어떤 부분*** 이다. 

일반적인 32비트 운영체제에서는 주소값이 32비트 즉 4바이트 사이즈로 지정된다. 따라서 2의 32승이 최대로 가질 수 있는 메모리 값이다. 이 운영체제에서는 16진수로 표현할 때, 8자리로 주소값이 출력된다.(64비트 운영체제에서는 16자리이다.)

여기서 이 주소값을 저장할 수 있는 새로운 자료형을 만든다. 이 자료형의 이름이 포인터라는것이다. int가 정수형 변수를 저장하고, float가 실수형 변수를 저장하는 것처럼, 포인터는 *( )형 변수를 저장하게 된다.

int *p;
이는 p라는 포인터를 선언하는 코드이다. 이 포인터는 int를 저장하는 저장소의 주소를 그 값으로 받게 될것이다. int를 앞에 붙인 이유도 그것이다. 시작주소만 알면 컴퓨터는 해당 주소에서 얼마나 되는 저장공간을 잡아서 데이터를 읽어올 지 모른다. 따라서 int라고 명시해줌으로서 컴퓨터가 해당주소로부터 4바이트만큼 읽어올 수 있도록 해주는 것이다.

이제 여기에 주소값을 실재로 지정해보자.
```
#include <stdio.h>
int main() {
  int *p;
  int a;

  p = &a;

  printf("포인터 p 에 들어 있는 값 : %p \n", p);
  printf("int 변수 a 가 저장된 주소 : %p \n", &a);

  return 0;
}
```
&a는 a가 저장된 주소의 시작점을 의미한다. 이 코드를 실행하면 다음과 같다.
```
포인터 p 에 들어 있는 값 : 0x7fff894c8b3c 
int 변수 a 가 저장된 주소 : 0x7fff894c8b3c 
```
왜 12자리일까? 그 이유는 앞의 4자리가 모두 0이라 잘려서 표현되었기 때문이다. 본론으로 돌아가, 결국 p는 우리가 예상했던 대로 a의 주소를 출력하였다.

그렇다면 p를 통해서 a로 접근할 수 있지 않을까? 그 역할을 해주는 것이 바로 *이다.

다음 코드를 보자.
```
#include <stdio.h>
int main() {
  int *p;
  int a;

  p = &a;
  a = 2;

  printf("a 의 값 : %d \n", a);
  printf("*p 의 값 : %d \n", *p);

  return 0;
}
```
둘다 2가 출력되는 것을 볼 수 있다.

이제 포인터의 기본에 관하여 알아보았으니, 응용에 도전해보자.

### 2)pointer의 활용
저번 포스트에서 const형에 관하여 알아보았다. const로 지정된 변수는 상수로 성질이 바뀌어서 이후 프로그램에서 값이 변경되면 오류가 나게 되어있다. 그렇다면 pointer에서 const를 활용할 수 있을까?
```
#include <stdio.h>
int main() {
  int a;
  int b;
  const int* pa = &a;

  *pa = 3;  // 올바르지 않은 문장
  pa = &b;  // 올바른 문장
  return 0;
}
```
왜 *pa = 3가 올바르지 않은 문장일까?  a가 선언되면서 a 안에는 이미 trash 값이 들어가 있는 상태이다. 여기에 const int *pa 라고 *pa가 가리키는 값 즉 a를 const int라 선언하였다. 이에 컴퓨터는 *pa = 3;를 const 값을 바꾸려는 시도로 인식한 것이다.

다른 예제를 보자.
```
#include <stdio.h>
int main() {
  int a;
  int b;
  int* const pa = &a;

  *pa = 3;  // 올바른 문장
  pa = &b;  // 올바르지 않은 문장

  return 0;
}
```
여기서 우리는 int* 를 가리키는 pa 라는 포인터를 정의하였다. 하지만 const는 pa를 수식하고 있다. 즉 *pa가 아니라 pa를 바꾸지 말라는 의미이다. 따라서 pa = &b가 올바르지 않은 문장이 된 것이다.

다음은 포인터의 덧셈과 뺄셈에 관하여 이야기를 나누려고 한다. 이것도 메모리에 관한 이해가 있으면 쉽게 받아드릴 수 있다.
```
#include <stdio.h>
int main() {
  int a;
  int* pa;
  pa = &a;

  printf("pa 의 값 : %p \n", pa);
  printf("(pa + 1) 의 값 : %p \n", pa + 1);

  return 0;
}
```
컴파일해보면 다음과 같다.
```
pa 의 값 : 0x7ffd6a32fc4c 
(pa + 1) 의 값 : 0x7ffd6a32fc50 
```
놀랍게도 나는 int* 형의 pa에 1을 더했는데 주소값은 4가 더해졌다는 사실을 알 수 있다. 이는 포인터의 가장 중요한 성질 중 하나로, 포인터에 1을 더하면 해당 포인터가 가리키는 변수형의 메모리 차지양만큼 주소값이 더해진다는 사실이다. 즉 int값은 4바이트 메모리를 차지하니 주소값에서 4만큼 더해진것이다.

나는 사실 이 개념을 받아들이는 데 시간이 오래 걸렸다. 언뜻 보면, 주소값은 8바이트 즉 64비트인데, 여기서 4를 더하면 4비트가 더해지는것이 아닌가? 라는 생각이 든것이다. 왜 int변수 즉 4바이트만큼 메모리가 이동하지?

하지만 정답은 생각보다 간단했다. 주소값 단위 1이 메모리 단위 1과 1대1로 대응한다는 생각이 틀렸던 것이다. 주소가 1비트 올라가면 메모리가 1바이트 올라간다고 생각하니, 위 개념이 이해가 가기 시작했다.

본론으로 돌아와서 char 은 1 바이트, double 은 8 바이트 int는 4바이트만큼 주소에 더해지게 된다. 포인터의 뺄셈도 동일하게 진행된다.

그렇다면 이러한 포인터의 특성은 왜 존재하는 것일까? 놀랍게도 이는 배열과 관련이 있다.

### 3)pointer과 배열
앞서 포인터의 덧셈과 뺄셈에 관하여 다루었다. 이러한 포인터의 특징은 사실 배열에 접근하기 위해서 만들어진것이다.

int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};라는 배열을 정의하게 되면, 배열은 메모리상에서 첫 주소값 이후로 연속되게 저장된다. 즉 크기 10의 int 배열이니, 40만큼의 주소값을 차지한다는 의미이다. 

여기서 감을 잡을 수 있다. 포인터 pa + 1은 사실 배열에서 원소 사이를 쉽게 옮겨 다니려고 만들어진 특성인 것이다.
```
#include <stdio.h>
int main() {
  int arr[10] = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10};
  int* parr;
  int i;
  parr = &arr[0];

  for (i = 0; i < 10; i++) {
    printf("arr[%d] 의 주소값 : %p ", i, &arr[i]);
    printf("(parr + %d) 의 값 : %p ", i, (parr + i));

    if (&arr[i] == (parr + i)) {
      /* 만일 (parr + i) 가 성공적으로 arr[i] 를 가리킨다면 */
      printf(" --> 일치 \n");
    } else {
      printf("--> 불일치\n");
    }
  }
  return 0;
}
```
실행시켜보면 전부다 일치가 나오는 것을 볼 수 있다.

배열의 주소값에는 기묘한 특징이 하나 있는데 이는 다음 코드를 보면 알 수 있다.
```
#include <stdio.h>
int main() {
  int arr[3] = {1, 2, 3};

  printf("arr 의 정체 : %p \n", arr);
  printf("arr[0] 의 주소값 : %p \n", &arr[0]);

  return 0;
}
```
둘의 값이 일치한다는 것을 볼 수 있다. arr은 그냥 선언되었을 때, arr[0]의 주소값을 출력한다. ***그렇다고 둘이 동일한 존재라는 것은 아니다.***

항상 기억하자 ***배열은 배열이고, 포인터는 포인터이다.***

다음과 같은 sizeof를 사용하는 코드를 보자.
```
#include <stdio.h>
int main() {
  int arr[6] = {1, 2, 3, 4, 5, 6};
  int* parr = arr;

  printf("Sizeof(arr) : %d \n", sizeof(arr));
  printf("Sizeof(parr) : %d \n", sizeof(parr));
}
```
arr은 24, parr은 8이 나온다는 것을 볼 수 있다. 즉 arr은 배열인 것이다. 그렇다면 왜 arr을 출력했을 때 주소값이 나온 것일까? 그 이유는 C 언어 상에서 배열의 이름이 sizeof 연산자나 주소값 연산자(&)와 사용될 때 (예를 들어 &arr) 경우를 빼면, 배열의 이름을 사용시 암묵적으로 첫 번째 원소를 가리키는 포인터로 타입 변환되기 때문이다.

이는 C언어의 특징이다. 왜 이렇게 설정되었는지는 후에 서술하겠다.

### 4)pointer와 []연산자
[]가 연산자였다는 사실을 모르는 사람들이 많았을 것이다.(나도 포함이다.)

그렇다면 어떻게 이게 연산자로 역할을 수행한다는 것일까? 다음 코드를 보자.
```
#include <stdio.h>
int main() {
  int arr[5] = {1, 2, 3, 4, 5};

  printf("a[3] : %d \n", arr[3]);
  printf("*(a+3) : %d \n", *(arr + 3));
  return 0;
}
```
 이제 여러분은 [] 연산자가 배열에서 다음과 같은 역할을 수행한다는 사실을 알 수 있을것이다.
 arr[3] = *(arr + 3)
 이는 다음과 같은 신기한 연산도 가능하게 만들어준다. 3[arr] = *[arr+3]
 
 이번 포스트에서 우리는 포인터의 기본과 이를 배열에 어떻게 적용하는지에 관하여 배웠다. 다음 포스트에서는 배열을 좀더 깊게 파보며 포인터의 심화 학습을 해보도록 하겠다.