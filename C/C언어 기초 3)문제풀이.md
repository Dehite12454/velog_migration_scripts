저번 포스팅에서 이야기 한 것처럼, 이번 포스팅은 내가 복습하는 데 사용한 교재인 씹어먹는 c언어에 수록된 중간 점검 문제들을 풀이해보겠다.

### 1)n줄인 삼각형을 출력하라.
사용자가 n값을 입력하면 n줄인 피라미드 모양의 삼각형을 출력하는 문제이다.
n=3 일때 예시
```
  *
 ***
*****
```
규칙성을 간단하게 발견할 수 있다. n=3일 때, 별의 개수가 1 3 5 이렇게 숫자가 증가하므로, 간단하게 5X5격자무늬를 머리속에 그리고 문제를 들어가면 쉽게 풀 수 있다. [5 = n*2 - 1]
첫줄부터 간단하게 별의 위치의 규칙성을 구상해보면, 첫줄은 5칸 중 3번째 칸에만 별을 채워 넣는다. 이때, 둘째줄은 3번칸 기준 +-1칸, 셋째줄은 3번째 칸 기준 +-2칸이다.
따라서 5번 루프하는 for 문을 잡고, 1씩 증가하는 변수로 별의 위치 범위를 지정하면 된다.
이를 코드로 실현하면 다음과 같다.
```
#include <stdio.h>  // n줄인 삼각형을 출력하라.
int main(){
    int num;
    printf("what is your number?\n");
    scanf("%d",&num);

    int b;
    int c;
    for (c = 0;c<num;c++){	// 줄 개수
        for (b = 1; b<num*2 ;b++){	// 한 줄을 채우는 for 문
            if (b>=num-c && b<=num+c){	// 별의 범위
                printf("*");
            }
            else {
                printf(" ");
            }
        }
        printf("\n");
    }
    return 0;
}
```
위와 같이 코드를 실행하면 문제에서 요구한 피라미드 모양의 삼각형이 그려지는 것을 확인할 수 있다.

### 2)n줄인 역삼각형 출력하기.
위의 방식을 그대로 유지하되, 첫줄과 마지막 줄 순서만 반대로 지정하면 된다.
아래와 같은 간단한 수정으로 문제를 해결할 수 있다.

```
#include <stdio.h>  //n줄인 역삼각형 그리기
int main(){
    int num;
    printf("what is your number?\n");
    scanf("%d",&num);

    int b;
    int c;
    for (c = num-1;c>=0;c--){	// 첫줄과 마지막 줄 순서 바꾸기
        for (b = 1; b<num*2 ;b++){
            if (b>=num-c && b<=num+c){
                printf("*");
            }
            else {
                printf(" ");
            }
        }
        printf("\n");
    }
    return 0;
}
```

### 3)합이 2000이 되는 a,b,c 집합 구하기(단 a>b>c 를 만족하는 자연수여야 한다.)

위와 같은 조건은 a부터 하나씩 for문으로 묶으면 간단하게 계산이 가능하다.
먼저 a를 1부터 1998까지 for문을 돌린다.(이때 1998이 최대가 되어야 한다. b,c가 자연수이므로) 그리고 b를 2000-a까지 for 문을 돌리고, c는 자동으로 지정된다.
이렇게 합이 2000이 되는 전체 집합을 구하였다. 하지만 우리는 a>b>c에만 관심이 있으므로 마지막에 if 조건문으로 해당 조건을 만족하는 집합만 세주면 된다.
코드는 다음과 같다.
```
#include <stdio.h>  //합이 2000이 되는 a,b,c 집합 구하기(단 a>b>c 를 만족하는 자연수여야 한다.)
int main(){
    int a,b,c;
    int count = 0;
    for(a = 1;a<2000-1 ;a++){	//a 지정
        for (b = 1;b<2000-a;b++){	//b 지정
            c = 2000-a-b;	//c 지정
            if (a>b && b>c){	//a,b,c, 조건 지정
                count++;
            }
        }
    }

    printf("%d",count);

    return 0;
}
```

### 4)사용자가 지정한 N을 소인수 분해하기
N을 소인수 분해하려면 N의 약수가 되는 가장 작은 소수부터 하나씩 찾아 나가야 한다.
여기서 중요한 점을 해당 약수가 한번 더 나누어질 수 있다는 점이다.(이를 위해서 무한 루프로 약수 판별 코드를 묶는다는 아이디어를 떠올렸다.)
문제에서 제시한 표현 방식은 18 = 2*3*3 처럼 출력되어야 한다는 것이었는데, 여기서 마지막 3 뒤에는 *표시가 없다는 사실에 주목하자.

먼저 N을 잡는다. 그리고 1부터 N까지 모든 수로 N을 나누어보면서 약수를 판별하게 되는데, 이때 N을 해당 소수로 나누었을 때를 기준으로 같은 소수를 계속해서 나누어 봐야 한다. 이를 무한루프로 묶는다. (만약 더이상 나누어지지 않으면 break를 통해서 탈출.)
여기서 중요한 점은 출력 형식을 맞추기 위해 소수를 구하면 뒤에 *을 출력하는 코드를 덧붙여야 한다는 점이다. 여기서 문제가 발생한다. 위에서 말했듯이 마지막 소수 뒤에는 곱하기를 붙이면 안된다.

만약 현재 소수가 마지막 소수라는 사실을 컴퓨터가 알면 숫자만 출력하고 프로그램을 끝낼 수 있을것이다. 따라서 temp라는 N값을 임시로 받을 변수를 잡고 소수에 대해서 계속 나눈다. 어떤 수로 temp을 나누었을때 최종적으로 temp가 1이 되면 프로그램을 종료하도록 설정하였다.

결과는 아래와 같다.
```
#include <stdio.h>  //소인수 분해
int main(){
    int N;
    int temp;
    int i;
    printf("what is your number?");
    scanf("%d",&N);

    temp = N;
    printf("%d = ",N);

    for (i = 2;i<=N;i++){
        for (;;){ 
            if (temp%i != 0){
                break;
            }
            else {
                printf("%d",i);
                temp = temp/i;
                if (temp == 1){
                    break;
                }
            }
            printf("*");
        }
    }
    return 0;
}
```

연습문제를 풀면서 간단하게 c언어를 복습해보는 시간을 가졌다. 다음 포스트부터는 다시 이론적인 부분에서 틀릴만한 곳들을 기록하는 형태로 진행될 예정이다.